name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'feature/**'
      - 'fix/**'
      - 'hotfix/**'
  pull_request:
    branches: ['main', 'develop']

# Cancel in-progress runs for the same workflow and branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.25.1'
  PROTOC_VERSION: '25.1'

jobs:
  # Setup job to cache dependencies and generate proto files once
  setup:
    name: Setup & Cache
    runs-on: ubuntu-latest
    outputs:
      go-cache-key: ${{ steps.go-cache.outputs.cache-hit }}
      proto-cache-key: ${{ steps.proto-cache.outputs.cache-hit }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: go.sum

      # Cache Go dependencies
      - name: Cache Go modules
        id: go-cache
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        if: steps.go-cache.outputs.cache-hit != 'true'
        run: go mod download

      # Cache protoc binary
      - name: Cache protoc
        id: cache-protoc
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/bin/protoc
            /usr/local/include/google
          key: protoc-${{ env.PROTOC_VERSION }}-${{ runner.os }}

      - name: Install protoc
        if: steps.cache-protoc.outputs.cache-hit != 'true'
        run: |
          PROTOC_ZIP=protoc-${{ env.PROTOC_VERSION }}-linux-x86_64.zip
          curl -OL https://github.com/protocolbuffers/protobuf/releases/download/v${{ env.PROTOC_VERSION }}/$PROTOC_ZIP
          sudo unzip -o $PROTOC_ZIP -d /usr/local bin/protoc
          sudo unzip -o $PROTOC_ZIP -d /usr/local 'include/*'
          rm -f $PROTOC_ZIP

      # Cache protoc-gen-go tools
      - name: Cache protoc-gen tools
        id: cache-protoc-gen
        uses: actions/cache@v4
        with:
          path: ~/go/bin
          key: protoc-gen-${{ runner.os }}-${{ hashFiles('go.mod') }}

      - name: Install protoc-gen tools
        if: steps.cache-protoc-gen.outputs.cache-hit != 'true'
        run: |
          go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

      # Generate proto files once
      - name: Cache generated proto files
        id: proto-cache
        uses: actions/cache@v4
        with:
          path: shared/proto
          key: proto-${{ hashFiles('proto/**/*.proto') }}

      - name: Generate protobuf
        if: steps.proto-cache.outputs.cache-hit != 'true'
        run: make generate-proto

      # Upload proto files as artifact for other jobs
      - name: Upload proto artifacts
        uses: actions/upload-artifact@v4
        with:
          name: proto-files
          path: shared/proto
          retention-days: 1

  # Run tests in parallel with minimal services
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: [setup]
    services:
      postgres:
        image: postgres:15-alpine # Use alpine for faster startup
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 3s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine # Use alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 5
        ports:
          - 6379:6379

      mongodb:
        image: mongo:7
        env:
          MONGO_INITDB_ROOT_USERNAME: root
          MONGO_INITDB_ROOT_PASSWORD: password
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.runCommand(\"ping\").ok'"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 5
        ports:
          - 27017:27017

      rabbitmq:
        image: rabbitmq:3-alpine # Use alpine
        env:
          RABBITMQ_DEFAULT_USER: guest
          RABBITMQ_DEFAULT_PASS: guest
        options: >-
          --health-cmd "rabbitmq-diagnostics -q check_running"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 5
        ports:
          - 5672:5672

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: go.sum

      # Restore caches from setup job
      - name: Restore Go modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Download proto artifacts
        uses: actions/download-artifact@v4
        with:
          name: proto-files
          path: shared/proto

      # Run tests without verbose flag for speed
      - name: Run tests with coverage
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          MONGODB_HOST: localhost
          MONGODB_PORT: 27017
          MONGODB_USER: root
          MONGODB_PASSWORD: password
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: 5672
          RABBITMQ_USER: guest
          RABBITMQ_PASSWORD: guest
        run: |
          # Run tests without -v flag for faster execution
          go test -race -coverprofile=coverage.out -covermode=atomic -timeout=10m ./...

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  # Build all services in parallel (no dependency on test)
  build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [setup]
    strategy:
      fail-fast: false # Continue building other services if one fails
      matrix:
        service:
          - auth-service
          - catalog-service
          - chain-registry-service
          - graphql-gateway
          - media-service
          - orchestrator-service
          - user-service
          - indexer-service
          - subscription-worker
          - wallet-service
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: go.sum

      # Restore caches
      - name: Restore Go modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Download proto artifacts
        uses: actions/download-artifact@v4
        with:
          name: proto-files
          path: shared/proto

      # Build without verbose flag
      - name: Build ${{ matrix.service }}
        run: |
          if [ -f "services/${{ matrix.service }}/cmd/main.go" ]; then
            cd services/${{ matrix.service }}
            go build -ldflags="-s -w" -o bin/${{ matrix.service }} cmd/main.go
          elif [ -f "services/${{ matrix.service }}/main.go" ]; then
            cd services/${{ matrix.service }}
            go build -ldflags="-s -w" -o bin/${{ matrix.service }} main.go
          else
            echo "No main.go found for ${{ matrix.service }}"
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-binary
          path: services/${{ matrix.service }}/bin/${{ matrix.service }}
          retention-days: 1
          compression-level: 9

  # Run security scan in parallel
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [setup]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      # Restore Go modules cache
      - name: Restore Go modules cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      # Cache gosec binary
      - name: Cache gosec
        id: cache-gosec
        uses: actions/cache@v4
        with:
          path: ~/go/bin/gosec
          key: gosec-${{ runner.os }}

      - name: Install Gosec
        if: steps.cache-gosec.outputs.cache-hit != 'true'
        run: |
          curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s -- -b $(go env GOPATH)/bin

      - name: Run Gosec Security Scanner
        run: |
          $(go env GOPATH)/bin/gosec -fmt sarif -out gosec.sarif ./... || true
          $(go env GOPATH)/bin/gosec ./... || true
        continue-on-error: true

      - name: Upload SARIF file
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: gosec.sarif

  # Lint job (optional, runs in parallel)
  lint:
    name: Lint
    runs-on: ubuntu-latest
    needs: [setup]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      # Use golangci-lint action with cache
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          version: v1.65.3
          args: --timeout=10m
          skip-cache: false
          skip-pkg-cache: false
          skip-build-cache: false
          install-mode: binary

  # Final status check
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [test, build, security, lint]
    if: always()
    steps:
      - name: Check test status
        if: needs.test.result != 'success'
        run: exit 1

      - name: Check build status
        if: needs.build.result != 'success'
        run: exit 1

      - name: All checks passed
        run: echo "âœ… All CI checks passed successfully!"
